<!doctype html>
<html lang="en-GB-oxendict">
<head>
<meta charset="utf8">
<link href="ecmarkup.css" rel="stylesheet">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/solarized-light.min.css">
</head>

<body>
<pre class="metadata">
title: 'ShadowRealm API'
stage: 3
contributors: Dave Herman, Caridy Pati√±o, Mark Miller, Leo Balter
status: proposal
copyright: false
location: https://tc39.es/proposal-shadowrealm/
</pre>
<emu-biblio href="./biblio.json"></emu-biblio>

<emu-clause id="sec-well-known-intrinsic-objects">
	<h1>Well-known intrinsic objects</h1>
	<emu-table id="table-7" caption="Well-known Intrinsic Objects">
		<table>
			<tbody>
				<tr>
					<th>Intrinsic Name</th>
					<th>Global Name</th>
					<th>ECMAScript Language Association</th>
				</tr>
				<tr>
					<td>%ShadowRealm%</td>
					<td>`ShadowRealm`</td>
					<td>The ShadowRealm constructor (<emu-xref href="#sec-shadowrealm-constructor"></emu-xref>)</td>
				</tr>
			</tbody>
		</table>
	</emu-table>
</emu-clause>

<emu-clause id="sec-wrapped-module-namespace-exotic-objects">
	<h1>Wrapped Module Namespace Exotic Objects</h1>
	<p>A wrapped module namespace exotic object is an exotic object that exposes the bindings exported from an ECMAScript |Module| (See <emu-xref href="#sec-exports"></emu-xref>). There is a one-to-one correspondence between the String-keyed own properties of a wrapped module namespace exotic object and the binding names exported by the |Module|. The exported bindings include any bindings that are indirectly exported using `export *` export items. Each String-valued own property key is the StringValue of the corresponding exported binding name. These are the only String-keyed properties of a wrapped module namespace exotic object. Each such property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }. Module namespace exotic objects are not extensible.</p>
	<p>An object is a <dfn id="wrapped-module-namespace-exotic-object" variants="wrapped module namespace exotic objects">wrapped module namespace exotic object</dfn> if its [[Get]] internal method use the definitions in this section, and its other essential internal methods use the definitions found in <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref>. These methods are installed by WrappedModuleNamespaceCreate.</p>
	<p>Wrapped module namespace exotic objects have the internal slots defined in <emu-xref href="#table-internal-slots-of-wrapped-module-namespace-exotic-objects"></emu-xref>.</p>
	<emu-table id="table-internal-slots-of-wrapped-module-namespace-exotic-objects" caption="Internal Slots of Wrapped Module Namespace Exotic Objects" oldids="table-29">
		<table>
			<tr>
				<th>
					Internal Slot
				</th>
				<th>
					Type
				</th>
				<th>
					Description
				</th>
			</tr>
			<tr>
				<td>
					[[Module]]
				</td>
				<td>
					a Module Record
				</td>
				<td>
					The Module Record whose exports this namespace exposes.
				</td>
			</tr>
			<tr>
				<td>
					[[Exports]]
				</td>
				<td>
					a List of Strings
				</td>
				<td>
					A List whose elements are the String values of the exported names exposed as own properties of this object. The list is ordered as if an Array of those String values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.
				</td>
			</tr>
			<tr>
				<td>
					[[Realm]]
				</td>
				<td>
					a Realm Record
				</td>
				<td>
					The Realm Record in which the Wrapped Module Namespace Exotic object was created.
				</td>
			</tr>
		</table>
	</emu-table>

	<emu-clause id="sec-wrapped-module-namespace-exotic-objects-get-p-receiver" type="internal method">
		<h1>
			[[Get]] (
				_P_: a property key,
				_Receiver_: an ECMAScript language value,
			): either a normal completion containing an ECMAScript language value or a throw completion
		</h1>
		<dl class="header">
			<dt>for</dt>
			<dd>a wrapped module namespace exotic object _O_</dd>
		</dl>
		<emu-alg>
			1. If Type(_P_) is Symbol, then
				1. Return ! OrdinaryGet(_O_, _P_, _Receiver_).
			1. Let _exports_ be _O_.[[Exports]].
			1. If _P_ is not an element of _exports_, return *undefined*.
			1. Let _m_ be _O_.[[Module]].
			1. Let _realm_ be _O_.[[Realm]].
			1. Let _binding_ be ! _m_.ResolveExport(_P_).
			1. Assert: _binding_ is a ResolvedBinding Record.
			1. Let _targetModule_ be _binding_.[[Module]].
			1. Assert: _targetModule_ is not *undefined*.
			1. If _binding_.[[BindingName]] is ~namespace~, then
				1. Let _namespace_ be ? GetModuleNamespace(_targetModule_).
				1. Return WrappedModuleNamespaceCreate(_realm_, _namespace_.[[Module]], _namespace_.[[Exports]]).
			1. Let _targetEnv_ be _targetModule_.[[Environment]].
			1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.
			1. Let _value_ be _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).
			1. NOTE: To avoid dynamic scoping get the realm to wrap the value from the wrapped module namespace exotic object.
			1. Return ? GetWrappedValue(_realm_, _value_).
		</emu-alg>
		<emu-note>
			<p>ResolveExport is side-effect free. Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each module namespace exotic object.</p>
		</emu-note>
	</emu-clause>

	<emu-clause id="sec-wrappedmodulenamespacecreate" type="abstract operation">
		<h1>
			WrappedModuleNamespaceCreate (
				_callerRealm_: a Realm Record,
				_module_: a Module Record,
				_exports_: a List of Strings,
			): a wrapped module namespace exotic object
		</h1>
		<dl class="header">
			<dt>description</dt>
			<dd>It is used to specify the creation of new wrapped module namespace exotic objects.</dd>
		</dl>
		<emu-alg>
			1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href="#table-internal-slots-of-wrapped-module-namespace-exotic-objects"></emu-xref>.
			1. Let _M_ be MakeBasicObject(_internalSlotsList_).
			1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href="#sec-wrapped-module-namespace-exotic-objects"></emu-xref>.
			1. Set _M_.[[Module]] to _module_.
			1. Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.
			1. Set _M_.[[Exports]] to _sortedExports_.
			1. Set _M_.[[Realm]] to _callerRealm_.
			1. Create own properties of _M_ corresponding to the definitions in <emu-xref href="#sec-wrapped-module-namespace-exotic-objects"></emu-xref>.
			1. Return _M_.
		</emu-alg>
	</emu-clause>
</emu-clause>

<emu-clause id="sec-finishshadowrealmimport" type="abstract operation">
	<h1>
		FinishShadowRealmImport (
			_callerRealm_: a Realm Record,
			_specifier_: unknown,
			_promiseCapability_: a PromiseCapability Record,
			_innerPromise_: unknown,
		): ~unused~
	</h1>
	<dl class="header">
		<dt>description</dt>
		<dd>FinishShadowRealmImport completes the process of importing a module into a ShadowRealm, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution. It is performed by host environments as part of HostImportValueModuleDynamically.</dd>
	</dl>
	<emu-alg>
		1. Let _fulfilledClosure_ be a new Abstract Closure in the context of _callerRealm_ with parameters (_result_) that captures _specifier_, and _promiseCapability_ and performs the following steps when called:
			1. Assert: _result_ is *undefined*.
			1. Let _runningContext_ be the running execution context.
			1. If _runningContext_ is not already suspended, suspend _runningContext_.
			1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.
			1. Let _moduleRecord_ be ! HostResolveImportedModule(*null*, _specifier_).
			1. Assert: Evaluate has already been invoked on _moduleRecord_ and successfully completed.
			1. Let _namespace_ be Completion(GetModuleNamespace(_moduleRecord_)).
			1. Suspend _evalContext_ and remove it from the execution context stack.
			1. Resume the context that is now on the top of the execution context stack as the running execution context.
			1. If _namespace_ is an abrupt completion, then
				1. Let _error_ be an Error object from _callerRealm_ equivalent to _namespace_.[[Value]].
				1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).
			1. Else,
				1. Let _wrappedNamespaceValue_ be WrappedModuleNamespaceCreate(_callerRealm_, _namespace_.[[Module]], _namespace_.[[Exports]]).
				1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _wrappedNamespaceValue_ &raquo;).
			1. Return ~unused~.
		1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, &laquo; &raquo;).
		1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _promiseCapability_ and performs the following steps when called:
			1. Assert: _error_ is an Error object from _callerRealm_.
			1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).
			1. Return ~unused~.
		1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *""*, &laquo; &raquo;).
		1. Perform PerformPromiseThen(_innerPromise_, _onFulfilled_, _onRejected_).
		1. Return ~unused~.
	</emu-alg>
</emu-clause>

<emu-clause id="sec-hostimportvaluemoduledynamically" type="host-defined abstract operation">
	<h1>
		HostShadowRealmImportModuleDynamically(
			_specifier_: a |ModuleSpecifier| String,
			_promiseCapability_: a PromiseCapability Record,
			_callerRealm_: a Realm Record,
			_evalRealm_: a Realm Record,
			_evalContext_: an execution context,
		): ~unused~
	</h1>
	<dl class="header">
		<dt>description</dt>
		<dd>It performs any necessary setup work in order to make available the module corresponding to _specifier_ occurring in the context of _evalContext_ for the _evalRealm_ with no active script or module. It then performs FinishShadowRealmImport to finish the import process.</dd>
	</dl>
	<p>An implementation of HostImportValueModuleDynamically must conform to the following requirements:</p>

	<ul>
		<li>
		It must return ~unused~. Success or failure must instead be signaled as discussed below.
		</li>
		<li>
		The host environment must conform to one of the two following sets of requirements:
		<dl>
			<dt>Success path</dt>

			<dd>
			<ul>
				<li>At some future time, the host environment must perform FinishShadowRealmImport(_callerRealm__, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise resolved with *undefined*.</li>

				<li>Any subsequent call to HostResolveImportedModule after FinishShadowRealmImport has completed, given the arguments *null* and _specifier_, must return a normal completion containing a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>
			</ul>
			</dd>

			<dt>Failure path</dt>

			<dd>
			<ul>
				<li>At some future time, the host environment must perform FinishShadowRealmImport(_callerRealm__, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise rejected with an error object from _callerRealm_ representing the cause of failure.</li>
			</ul>
			</dd>
		</dl>
		</li>
		<li>
		If the host environment takes the success path once for a given _specifier_, it must always do so for subsequent calls.
		</li>
		<li>
		The operation must not call _promiseCapability_.[[Resolve]] or _promiseCapability_.[[Reject]], but instead must treat _promiseCapability_ as an opaque identifying value to be passed through to FinishShadowRealmImport.
		</li>
	</ul>

	<p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to allow HostResolveImportedModule to synchronously retrieve the appropriate Module Record, and then calling its Evaluate concrete method. This might require performing similar normalization as HostResolveImportedModule does.</p>
</emu-clause>

<emu-clause id="sec-wrapped-function-exotic-objects">
	<h1>Wrapped Function Exotic Objects</h1>
	<p>A wrapped function exotic object is an exotic object that wraps a callable object. A wrapped function exotic object is callable (it has a [[Call]] internal method). Calling a wrapped function exotic object generally results in a call of its wrapped function.</p>

	<p>An object is a <dfn id="wrapped-function-exotic-object">wrapped function exotic object</dfn> if its [[Call]] internal method uses the following implementation, and its other essential internal methods use the definitions found in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. These methods are installed in WrappedFunctionCreate.</p>

	<p>Wrapped function exotic objects do not have the internal slots of ECMAScript function objects listed in <emu-xref aoid="Internal Slots of ECMAScript Function Objects"></emu-xref>. Instead they have the internal slots listed in <emu-xref href="#table-internal-slots-of-wrapped-function-exotic-objects"></emu-xref>, in addition to [[Prototype]] and [[Extensible]].</p>
	<emu-table id="table-internal-slots-of-wrapped-function-exotic-objects" caption="Internal Slots of Wrapped Function Exotic Objects">
	<table>
		<tbody>
		<tr>
		<th>
			Internal Slot
		</th>
		<th>
			Type
		</th>
		<th>
			Description
		</th>
		</tr>
		<tr>
		<td>
			[[WrappedTargetFunction]]
		</td>
		<td>
			Callable Object
		</td>
		<td>
			Stores the callable object.
		</td>
		</tr>
		<tr>
		<td>
			[[Call]]
		</td>
		<td>
			The [[Call]] internal method
		</td>
		<td>
			Executes code associated with this object's [[WrappedTargetFunction]].
		</td>
		</tr>
		<tr>
		<td>
			[[Realm]]
		</td>
		<td>
			Realm Record
		</td>
		<td>
			The realm in which the function was created.
		</td>
		</tr>
		</tbody>
	</table>
	</emu-table>

	<emu-clause id="sec-wrapped-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
		<h1>
			[[Call]] (
				_thisArgument_: an ECMAScript language value,
				_argumentsList_: a List of ECMAScript language values,
			)
		</h1>
		<dl class="header">
			<dt>for</dt>
			<dd>a wrapped function exotic object _F_</dd>
		</dl>
		<emu-alg>
			1. Let _callerContext_ be the running execution context.
			1. Let _calleeContext_ be PrepareForWrappedFunctionCall(_F_).
			1. Assert: _calleeContext_ is now the running execution context.
			1. Let result be OrdinaryWrappedFunctionCall(_F_, _thisArgument_, _argumentsList_).
			1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
			1. If result.[[Type]] is return, return result.[[Value]].
			1. ReturnIfAbrupt(result).
			1. Return *undefined*.
		</emu-alg>
		<emu-note type=editor>
			In the case of an abrupt ~throw~ completion, the type of error to be created should match the type of the abrupt throw completion record. This could be revisited when merging into the main specification. Additionally, in the case of a ~break~ or ~continue~ completion, since those are not supported, a TypeError is expected.
		</emu-note>
	</emu-clause>

	<emu-clause id="sec-ordinary-wrapped-function-call" type="abstract operation">
		<h1>
			OrdinaryWrappedFunctionCall (
				_F_: a wrapped function exotic object,
				_thisArgument_: an ECMAScript language value,
				_argumentsList_: a List of ECMAScript language values,
			)
		</h1>
		<emu-alg>
			1. Let _target_ be _F_.[[WrappedTargetFunction]].
			1. Assert: IsCallable(_target_) is *true*.
			1. Let _callerRealm_ be _F_.[[Realm]].
			1. NOTE: Any exception objects produced after this point are associated with _callerRealm_.
			1. Let _targetRealm_ be ? GetFunctionRealm(_target_).
			1. Let _wrappedArgs_ be a new empty List.
			1. For each element _arg_ of _argumentsList_, do
				1. Let _wrappedValue_ be ? GetWrappedValue(_targetRealm_, _arg_).
				1. Append _wrappedValue_ to _wrappedArgs_.
			1. Let _wrappedThisArgument_ to ? GetWrappedValue(_targetRealm_, _thisArgument_).
			1. Let _result_ be the Completion Record of Call(_target_, _wrappedThisArgument_, _wrappedArgs_).
			1. If _result_.[[Type]] is ~normal~ or _result_.[[Type]] is ~return~, then
				1. Return ? GetWrappedValue(_callerRealm_, _result_.[[Value]]).
			1. Else,
				1. Throw a *TypeError* exception.
		</emu-alg>
	</emu-clause>

	<emu-clause id="sec-prepare-for-wrapped-function-call" type="abstract operation">
		<h1>
			PrepareForWrappedFunctionCall (
				_F_: a wrapped function exotic object,
			)
		</h1>
		<emu-alg>
			1. Let callerContext be the running execution context.
			1. Let calleeContext be a new execution context.
			1. Set the Function of calleeContext to F.
			1. Let calleeRealm be F.[[Realm]].
			1. Set the Realm of calleeContext to calleeRealm.
			1. Set the ScriptOrModule of calleeContext to *null*.
			1. If callerContext is not already suspended, suspend callerContext.
			1. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
			1. NOTE: Any exception objects produced after this point are associated with calleeRealm.
			1. Return calleeContext.
		</emu-alg>
	</emu-clause>
</emu-clause>

<emu-clause id="sec-shadowrealm-objects">
	<h1>ShadowRealm Objects</h1>
	<emu-clause id="sec-shadowrealm-abstracts">
		<h1>ShadowRealm Abstract Operations</h1>

		<emu-clause id="sec-wrappedfunctioncreate" aoid="WrappedFunctionCreate" type="abstract operation">
			<h1>
				WrappedFunctionCreate (
					_callerRealm_: a Realm Record,
					_Target_: a function object,
				)
			</h1>
			<p>The abstract operation WrappedFunctionCreate takes arguments _callerRealm_ and _Target_. It is used to specify the creation of new wrapped function exotic objects. It performs the following steps when called:</p>
			<emu-alg>
				1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href="#table-internal-slots-of-wrapped-function-exotic-objects"></emu-xref>, plus [[Prototype]] and [[Extensible]].
				1. Let _wrapped_ be MakeBasicObject(_internalSlotsList_).
				1. Set _wrapped_.[[Prototype]] to _callerRealm_.[[Intrinsics]].[[%Function.prototype%]].
				1. Set _wrapped_.[[Call]] as described in <emu-xref href="#sec-wrapped-function-exotic-objects-call-thisargument-argumentslist"></emu-xref>.
				1. Set _wrapped_.[[WrappedTargetFunction]] to _Target_.
				1. Set _wrapped_.[[Realm]] to _callerRealm_.
				1. Let _result_ be CopyNameAndLength(_wrapped_, _Target_).
				1. If _result_ is an Abrupt Completion, throw a TypeError exception.
				1. Return _wrapped_.
			</emu-alg>
		</emu-clause>

		<emu-clause id="sec-copynameandlength" aoid="CopyNameAndLength" type="abstract operation">
			<h1>
				CopyNameAndLength (
					_F_: a function object,
					_Target_: a function object,
					optional _prefix_: a String,
					optional _argCount_: a Number,
				)
			</h1>
			<emu-alg>
				1. If _argCount_ is *undefined*, then set _argCount_ to 0.
				1. Let _L_ be 0.
				1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *"length"*).
				1. If _targetHasLength_ is *true*, then
					1. Let _targetLen_ be ? Get(_Target_, *"length"*).
					1. If Type(_targetLen_) is Number, then
						1. If _targetLen_ is *+&infin;*<sub>ùîΩ</sub>, set _L_ to +&infin;.
						1. Else if _targetLen_ is *-&infin;*<sub>ùîΩ</sub>, set _L_ to 0.
						1. Else,
							1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).
							1. Assert: _targetLenAsInt_ is finite.
							1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).
				1. Perform SetFunctionLength(_F_, _L_).
				1. Let _targetName_ be ? Get(_Target_, *"name"*).
				1. If Type(_targetName_) is not String, set _targetName_ to the empty String.
				1. Perform SetFunctionName(_F_, _targetName_, _prefix_).
			</emu-alg>

			<emu-note type=editor>
				Function.prototype.bind can replace steps 4 to 10 with this abstraction.
			</emu-note>

			<emu-clause id="sec-function.prototype.bind">
				<h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
				<p>When the `bind` method is called with argument _thisArg_ and zero or more _args_, it performs the following steps:</p>
				<emu-alg>
					1. Let _Target_ be the *this* value.
					1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.
					1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).
					1. <ins>Let _argCount_ be the number of elements in _args_.
					1. <ins>Perform ? CopyNameAndLength(_F_, _Target_, *"bound"*, _argCount_).
					1. <del>Let _L_ be 0.
					1. <del>Let _targetHasLength_ be ? HasOwnProperty(_Target_, *"length"*).
					1. <del>If _targetHasLength_ is *true*, then
						1. <del>Let _targetLen_ be ? Get(_Target_, *"length"*).
						1. <del>If Type(_targetLen_) is Number, then
						1. <del>If _targetLen_ is *+&infin;*<sub>ùîΩ</sub>, set _L_ to +&infin;.
						1. <del>Else if _targetLen_ is *-&infin;*<sub>ùîΩ</sub>, set _L_ to 0.
						1. <del>Else,
							1. <del>Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).
							1. <del>Assert: _targetLenAsInt_ is finite.
							1. <del>Let _argCount_ be the number of elements in _args_.
							1. <del>Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).
					1. <del>Perform SetFunctionLength(_F_, _L_).
					1. <del>Let _targetName_ be ? Get(_Target_, *"name"*).
					1. <del>If Type(_targetName_) is not String, set _targetName_ to the empty String.
					1. <del>Perform SetFunctionName(_F_, _targetName_, *"bound"*).</del>
					1. Return _F_.
				</emu-alg>
			</emu-clause>
		</emu-clause>

		<emu-clause id="sec-performshadowrealmeval" aoid="PerformShadowRealmEval" type="abstract operation">
			<h1>
				PerformShadowRealmEval (
					_sourceText_: a String,
					_callerRealm_: a Realm Record,
					_evalRealm_: a Realm Record,
				)
			</h1>
			<emu-alg>
				1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _evalRealm_).
				1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:
					1. Let _script_ be ParseText(StringToCodePoints(_sourceText_), |Script|).
					1. If _script_ is a List of errors, throw a *SyntaxError* exception.
					1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.
					1. Let _body_ be the |ScriptBody| of _script_.
					1. If _body_ Contains |NewTarget| is *true*, throw a *SyntaxError* exception.
					1. If _body_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
					1. If _body_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
				1. Let _strictEval_ be IsStrict of _script_.
				1. Let _runningContext_ be the running execution context.
				1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).
				1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].
				1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.
				1. If _runningContext_ is not already suspended, suspend _runningContext_.
				1. Let _evalContext_ be a new ECMAScript code execution context.
				1. Set _evalContext_'s Function to *null*.
				1. Set _evalContext_'s Realm to _evalRealm_.
				1. Set _evalContext_'s ScriptOrModule to *null*.
				1. Set _evalContext_'s VariableEnvironment to _varEnv_.
				1. Set _evalContext_'s LexicalEnvironment to _lexEnv_.
				1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.
				1. Let _result_ be Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, *null*, _strictEval_)).
				1. If _result_.[[Type]] is ~normal~, then
					1. Set _result_ to the result of evaluating _body_.
				1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
					1. Set result to NormalCompletion(*undefined*).
				1. Suspend _evalContext_ and remove it from the execution context stack.
				1. Resume the context that is now on the top of the execution context stack as the running execution context.
				1. If _result_.[[Type]] is not ~normal~, throw a *TypeError* exception.
				1. Return ? GetWrappedValue(_callerRealm_, _result_.[[Value]]).
			</emu-alg>
			<emu-note type=editor>
				In the case of an abrupt ~throw~ completion, the type of error to be created should match the type of the abrupt throw completion record. This could be revisited when merging into the main specification. Additionally, in the case of a ~break~ or ~continue~ completion, since those are not supported, a TypeError is expected. There should be no ~return~ completion because this is a top level script evaluation, in which case a return |Statement| must result in a parsing error.
			</emu-note>
			<emu-note type=editor>
				Some steps from PerformShadowRealmEval are shared with |eval| and |Function| and should result into a shared abstraction when merged to ECMA-262.
			</emu-note>
			<emu-note>
				This abstraction requires the performed evaluation to result into a normal completion. Otherwise, if the result is not a normal completion, the abstraction will throw a TypeError exception associated to its original running execution context.
			</emu-note>
		</emu-clause>

		<emu-clause id="sec-getwrappedvalue" aoid="GetWrappedValue" type="abstract operation">
			<h1>
				GetWrappedValue (
					_callerRealm_: a Realm Record,
					_value_: unknown,
				)
			</h1>
			<emu-alg>
				1. If Type(_value_) is Object, then
					1. If IsCallable(_value_) is *false*, throw a TypeError exception.
					1. Return ? WrappedFunctionCreate(_callerRealm_, _value_).
				1. Return _value_.
			</emu-alg>
		</emu-clause>

		<emu-clause id="sec-validateshadowrealmobject" aoid="ValidateShadowRealmObject" type="abstract operation">
			<h1>
				ValidateShadowRealmObject (
					_O_: unknown
				)
			</h1>
			<emu-alg>
				1. Perform ? RequireInternalSlot(_O_, [[ShadowRealm]]).
				1. Perform ? RequireInternalSlot(_O_, [[ExecutionContext]]).
			</emu-alg>
		</emu-clause>
	</emu-clause>

	<emu-clause id="sec-shadowrealm-constructor">
		<h1>The ShadowRealm Constructor</h1>
		<p>The ShadowRealm constructor:</p>
		<ul>
			<li>is the intrinsic object <dfn>%ShadowRealm%</dfn>.</li>
			<li>is the initial value of the *"ShadowRealm"* property of the global object.</li>
			<li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
			<li>creates and initializes a new ShadowRealm object when called as a constructor.</li>
			<li>is designed to be subclassable. It may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `ShadowRealm` behaviour must include a `super` call to the `ShadowRealm` constructor to create and initialize the subclass instance with the internal state necessary to support the `ShadowRealm.prototype` built-in methods.</li>
		</ul>

		<emu-clause id="sec-shadowrealm">
			<h1>ShadowRealm ( )</h1>
			<p>When the `ShadowRealm` function is called, the following steps are taken:</p>
			<emu-alg>
				1. If NewTarget is *undefined*, throw a *TypeError* exception.
				1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%ShadowRealm.prototype%"*, ¬´ [[ShadowRealm]], [[ExecutionContext]] ¬ª).
				1. Let _realmRec_ be CreateRealm().
				1. Set _O_.[[ShadowRealm]] to _realmRec_.
				1. Let _context_ be a new execution context.
				1. Set the Function of _context_ to *null*.
				1. Set the Realm of _context_ to _realmRec_.
				1. Set the ScriptOrModule of _context_ to *null*.
				1. Set _O_.[[ExecutionContext]] to _context_.
				1. Perform ? SetRealmGlobalObject(_realmRec_, *undefined*, *undefined*).
				1. Perform ? SetDefaultGlobalBindings(_O_.[[ShadowRealm]]).
				1. Perform ? HostInitializeShadowRealm(_O_.[[ShadowRealm]]).
				1. Return _O_.
			</emu-alg>
		</emu-clause>
	</emu-clause>

	<emu-clause id="sec-properties-of-the-shadowRealm-constructor">
		<h1>Properties of the ShadowRealm Constructor</h1>
		<p>The ShadowRealm constructor:</p>
		<ul>
			<li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
			<li>has the following properties:</li>
		</ul>

		<emu-clause id="sec-shadowrealm.prototype">
			<h1>ShadowRealm.prototype</h1>
			<p>The initial value of *ShadowRealm.prototype* is %ShadowRealm.prototype%.</p>
			<p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
		</emu-clause>
	</emu-clause>

	<emu-clause id="sec-properties-of-the-shadowrealm-prototype-object">
		<h1>Properties of the ShadowRealm Prototype Object</h1>
		<p>The ShadowRealm prototype object:</p>
		<ul>
			<li>has a [[Prototype]] internal slot whose value is <dfn>%Object.prototype%</dfn>.</li>
			<li>is %ShadowRealm.prototype%.</li>
			<li>is an ordinary object.</li>
			<li>does not have a [[ShadowRealm]] or any other of the internal slots that are specific to _Realm_ instance objects.</li>
		</ul>

		<emu-clause id="sec-shadowrealm.prototype.evaluate">
			<h1>ShadowRealm.prototype.evaluate ( _sourceText_ )</h1>

			<p>Synchronously execute a top-level script. The _sourceText_ is interpreted as a Script and evaluated with this bound to the shadowrealm's global object.</p>

			<emu-alg>
				1. Let _O_ be *this* value.
				1. Perform ? ValidateShadowRealmObject(_O_).
				1. If Type(_sourceText_) is not String, throw a *TypeError* exception.
				1. Let _callerRealm_ be the current Realm Record.
				1. Let _evalRealm_ be _O_.[[ShadowRealm]].
				1. Return ? PerformShadowRealmEval(_sourceText_, _callerRealm_, _evalRealm_).
			</emu-alg>

			<emu-note type=editor>
				Extensible web: This is the dynamic equivalent of a &lt;script&gt; in HTML.
			</emu-note>
		</emu-clause>

		<emu-clause id="sec-shadowrealm.prototype.import">
			<h1>ShadowRealm.prototype.import ( _specifier_ )</h1>
			<p>The following steps are performed:</p>
			<emu-alg>
				1. Let _O_ be *this* value.
				1. Perform ? ValidateShadowRealmObject(_O_).
				1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
				1. Let _specifierString_ be ? ToString(_specifier_).
				1. Let _callerRealm_ be the current Realm Record.
				1. Let _evalRealm_ be _O_.[[ShadowRealm]].
				1. Let _evalContext_ be _O_.[[ExecutionContext]].
				1. Perform HostShadowRealmImportModuleDynamically(_specifierString_, _promiseCapability_, _callerRealm_, _evalRealm_, _evalContext_).
				1. Return _promiseCapability_.[[Promise]].
			</emu-alg>

			<emu-note type=editor>
				Extensible web: This is equivalent to dynamic import without having to evaluate a script source, which might not be available (e.g.: when CSP is blocking source evaluation).
			</emu-note>
		</emu-clause>

		<emu-clause id="sec-shadowrealm.prototype-@@tostringtag">
			<h1>ShadowRealm.prototype [ @@toStringTag ]</h1>
			<p>The initial value of the @@toStringTag property is the String value *"ShadowRealm"*.</p>
			<p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
		</emu-clause>
	</emu-clause>

	<emu-clause id="sec-properties-of-shadowrealm-instances">
		<h1>Properties of ShadowRealm Instances</h1>
		<p>ShadowRealm instances are ordinary objects that inherit properties from the ShadowRealm prototype object (the intrinsic, %ShadowRealm.prototype%). ShadowRealm instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-shadowrealm-instances"></emu-xref>.</p>

		<emu-table id="table-internal-slots-of-shadowrealm-instances" caption="Internal Slots of ShadowRealm Instances">
			<table>
				<tbody>
					<tr>
						<th>Internal Slot</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td>[[ShadowRealm]]</td>
						<td>Realm Record</td>
						<td>The Realm Record for the initial execution context.</td>
					</tr>
					<tr>
						<td>[[ExecutionContext]]</td>
						<td>Execution context</td>
						<td>An execution context wherein the current Realm is this [[ShadowRealm]].</td>
					</tr>
				</tbody>
			</table>
		</emu-table>
	</emu-clause>

	<emu-clause id="sec-shadowrealm-host-operations">
		<h1>Host operations</h1>
		<emu-clause id="sec-host-initialize-shadow-shadowrealm" aoid="HostInitializeShadowRealm">
			<h1>Runtime Semantics: HostInitializeShadowRealm ( _realm_ )</h1>
			<p>
				HostInitializeShadowRealm is an implementation-defined abstract
				operation used to inform the host of any newly created realms from
				the ShadowRealm constructor. Its return value is not used, though it may
				throw an exception. The idea of this hook is to initialize host
				data structures related to the ShadowRealm, e.g., for module loading.
			</p>
			<p>
				The host may use this hook to add properties to the ShadowRealm's global
				object. Those properties must be configurable.
			</p>
			<emu-note>
				<p>
					This specification does not recommend any specific addition.
					In the Web embedding, HTML and WebIDL will specify which
					interfaces are included. The Web Platform and Web-like
					environments may decide to include `EventTarget`,
					`atob`, `TextEncoder`, `URL`, etc. while at the same time not
					including `HTMLElement`, `console`, `localStorage`, `fetch`, etc..
				</p>
			</emu-note>
			<emu-note type=editor>
				<p>
					The ShadowRealm constructor (<emu-xref href="#sec-shadowrealm"></emu-xref>
					creates a new global object as an ordinary object. This
					means all properties from the global object are deletable.
				</p>
			</emu-note>
		</emu-clause>
	</emu-clause>

</emu-clause>
</body>
</html>
